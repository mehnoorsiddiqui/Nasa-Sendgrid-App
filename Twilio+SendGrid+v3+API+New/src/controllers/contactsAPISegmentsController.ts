/**
 * Twilio SendGrid v3 APILib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

import { ApiError } from '@apimatic/core';
import { ApiResponse, RequestOptions } from '../core';
import {
  GlobalErrorResponseSchema1Error,
} from '../errors/globalErrorResponseSchema1Error';
import {
  ContactDBSegmentswithID,
  contactDBSegmentswithIDSchema,
} from '../models/contactDBSegmentswithID';
import {
  ContentTypeEnum,
  contentTypeEnumSchema,
} from '../models/contentTypeEnum';
import {
  CreateaSegmentrequest,
  createaSegmentrequestSchema,
} from '../models/createaSegmentrequest';
import {
  ListAllSegmentsresponse,
  listAllSegmentsresponseSchema,
} from '../models/listAllSegmentsresponse';
import {
  ListRecipientsOnaSegmentresponse,
  listRecipientsOnaSegmentresponseSchema,
} from '../models/listRecipientsOnaSegmentresponse';
import {
  V3ContactdbSegmentsRequest,
  v3ContactdbSegmentsRequestSchema,
} from '../models/v3ContactdbSegmentsRequest';
import {
  boolean,
  nullable,
  number,
  optional,
  string,
  unknown,
} from '../schema';
import { BaseController } from './baseController';

export class ContactsAPISegmentsController extends BaseController {
  /**
   * **This endpoint allows you to create a new segment.**
   *
   *
   * Valid operators for create and update depend on the type of the field for which you are searching.
   *
   * **Dates**
   * - "eq", "ne", "lt" (before), "gt" (after)
   * - You may use MM/DD/YYYY for day granularity or an epoch for second granularity.
   * - "empty", "not_empty"
   * - "is within"
   * - You may use an [ISO 8601 date format](https://en.wikipedia.org/wiki/ISO_8601) or the # of days.
   *
   * **Text**
   * - "contains"
   * - "eq" (is/equals - matches the full field)
   * - "ne" (is not/not equals - matches any field where the entire field is not the condition value)
   * - "empty"
   * - "not_empty"
   *
   * **Numbers**
   * - "eq" (is/equals)
   * - "lt" (is less than)
   * - "gt" (is greater than)
   * - "empty"
   * - "not_empty"
   *
   * **Email Clicks and Opens**
   * - "eq" (opened)
   * - "ne" (not opened)
   *
   * All field values must be a string.
   *
   *
   * Conditions using "eq" or "ne" for email clicks and opens should provide a "field" of either `clicks.
   * campaign_identifier` or `opens.campaign_identifier`.
   * The condition value should be a string containing the id of a completed campaign.
   *
   *
   * The conditions list may contain multiple conditions, joined by an "and" or "or" in the "and_or"
   * field.
   *
   * The first condition in the conditions list must have an empty "and_or", and subsequent conditions
   * must all specify an "and_or".
   *
   * @param onBehalfOf   Example: The subuser's username. This header generates the
   *                                                     API call as if the subuser account was making the call.
   * @param body
   * @return Response from the API call
   */
  async pOSTContactdbSegments(
    onBehalfOf?: string,
    body?: CreateaSegmentrequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ContactDBSegmentswithID>> {
    const req = this.createRequest('POST', '/v3/contactdb/segments');
    const mapped = req.prepareArgs({
      onBehalfOf: [onBehalfOf, optional(string())],
      body: [body, optional(createaSegmentrequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.header('on-behalf-of', mapped.onBehalfOf);
    req.json(mapped.body);
    req.throwOn(400, GlobalErrorResponseSchema1Error, '"name" : "Returned if the name is not valid"\n"list_id" : "Returned if the list_id is not valid"\n"and_or" : "Returned if and_or and set value is not passed into the request body"\n"and_or" : "Returned if and_or is set on the only condition passed"\n"and_or" : "Returned if and_or is set on all conditions"\n"and_or" : "Returned if and_or is not set on more than one condition and less than all conditions"\n"operator" : "Returned if operator and set value is not passed into the request body"\n"value" : "Returned if value and set value is not passed into the request body"\n"field" : "Returned if field and set value is not passed into the request body"\n"" : "Returned if request body is not valid json"\n"" : "Returned if invalid value is passed into one of the request body parameters"');
    req.throwOn(401, GlobalErrorResponseSchema1Error, '');
    return req.callAsJson(contactDBSegmentswithIDSchema, requestOptions);
  }

  /**
   * **This endpoint allows you to retrieve all of your segments.**
   *
   * @param onBehalfOf   Example: The subuser's username. This header generates the API call as if the
   *                               subuser account was making the call.
   * @return Response from the API call
   */
  async gETContactdbSegments(
    onBehalfOf?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ListAllSegmentsresponse>> {
    const req = this.createRequest('GET', '/v3/contactdb/segments');
    const mapped = req.prepareArgs({
      onBehalfOf: [onBehalfOf, optional(string())],
    });
    req.header('on-behalf-of', mapped.onBehalfOf);
    req.throwOn(401, GlobalErrorResponseSchema1Error, '');
    return req.callAsJson(listAllSegmentsresponseSchema, requestOptions);
  }

  /**
   * **This endpoint allows you to retrieve a single segment with the given ID.**
   *
   * @param segmentId    The ID of the segment you want to request.
   * @param onBehalfOf   Example: The subuser's username. This header generates the API call as if the
   *                               subuser account was making the call.
   * @return Response from the API call
   */
  async gETContactdbSegmentsSegmentId(
    segmentId: number,
    onBehalfOf?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<CreateaSegmentrequest>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      segmentId: [segmentId, number()],
      onBehalfOf: [onBehalfOf, optional(string())],
    });
    req.header('on-behalf-of', mapped.onBehalfOf);
    req.appendTemplatePath`/v3/contactdb/segments/${mapped.segmentId}`;
    req.throwOn(400, GlobalErrorResponseSchema1Error, '"segment_id" : "Returned if segment_id is not valid"');
    req.throwOn(401, GlobalErrorResponseSchema1Error, '');
    req.throwOn(404, GlobalErrorResponseSchema1Error, '"segment_id" : "Returned if segment_id does not exist"');
    return req.callAsJson(createaSegmentrequestSchema, requestOptions);
  }

  /**
   * **This endpoint allows you to update a segment.**
   *
   * @param segmentId    The ID of the segment you are updating.
   * @param onBehalfOf   Example: The subuser's username. This header generates
   *                                                          the API call as if the subuser account was making the
   *                                                          call.
   * @param body
   * @return Response from the API call
   */
  async pATCHContactdbSegmentsSegmentId(
    segmentId: string,
    onBehalfOf?: string,
    body?: V3ContactdbSegmentsRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<CreateaSegmentrequest>> {
    const req = this.createRequest('PATCH');
    const mapped = req.prepareArgs({
      segmentId: [segmentId, string()],
      onBehalfOf: [onBehalfOf, optional(string())],
      body: [body, optional(v3ContactdbSegmentsRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.header('on-behalf-of', mapped.onBehalfOf);
    req.json(mapped.body);
    req.appendTemplatePath`/v3/contactdb/segments/${mapped.segmentId}`;
    req.throwOn(400, GlobalErrorResponseSchema1Error, '400 error');
    req.throwOn(401, GlobalErrorResponseSchema1Error, '401 error');
    return req.callAsJson(createaSegmentrequestSchema, requestOptions);
  }

  /**
   * **This endpoint allows you to delete a segment from your recipients database.**
   *
   * You also have the option to delete all the contacts from your Marketing Campaigns recipient database
   * who were in this segment.
   *
   * @param segmentId
   * @param contentType
   * @param deleteContacts  True to delete all contacts matching the segment in addition to
   *                                           deleting the segment
   * @param onBehalfOf      Example: The subuser's username. This header generates the API call as
   *                                           if the subuser account was making the call.
   * @return Response from the API call
   */
  async dELETEContactdbSegmentsSegmentId(
    segmentId: string,
    contentType: ContentTypeEnum,
    deleteContacts?: boolean,
    onBehalfOf?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({
      segmentId: [segmentId, string()],
      contentType: [contentType, contentTypeEnumSchema],
      deleteContacts: [deleteContacts, optional(boolean())],
      onBehalfOf: [onBehalfOf, optional(string())],
    });
    req.header('Content-Type', mapped.contentType);
    req.header('on-behalf-of', mapped.onBehalfOf);
    req.query('delete_contacts', mapped.deleteContacts);
    req.appendTemplatePath`/v3/contactdb/segments/${mapped.segmentId}`;
    req.throwOn(400, GlobalErrorResponseSchema1Error, '"segment_id" : "Returned if segment_id is not valid"\n"delete_contacts" : "Returned if delete_contacts is not a valid boolean"');
    req.throwOn(401, GlobalErrorResponseSchema1Error, '');
    req.throwOn(404, GlobalErrorResponseSchema1Error, '"segment_id" : "Returned if segment_id does not exist"');
    return req.callAsJson(nullable(unknown()), requestOptions);
  }

  /**
   * **This endpoint allows you to retrieve all of the recipients in a segment with the given ID.**
   *
   * @param segmentId    The ID of the segment from which you want to retrieve recipients.
   * @param page
   * @param pageSize
   * @param onBehalfOf   Example: The subuser's username. This header generates the API call as if the
   *                               subuser account was making the call.
   * @return Response from the API call
   */
  async gETContactdbSegmentsSegmentIdRecipients(
    segmentId: number,
    page?: number,
    pageSize?: number,
    onBehalfOf?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ListRecipientsOnaSegmentresponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      segmentId: [segmentId, number()],
      page: [page, optional(number())],
      pageSize: [pageSize, optional(number())],
      onBehalfOf: [onBehalfOf, optional(string())],
    });
    req.header('on-behalf-of', mapped.onBehalfOf);
    req.query('page', mapped.page);
    req.query('page_size', mapped.pageSize);
    req.appendTemplatePath`/v3/contactdb/segments/${mapped.segmentId}/recipients`;
    req.throwOn(400, ApiError, '"page" : "Returned if page is not a valid integer"\n"page" : "Returned if page is less than 1"\n"page_size" : "Returned if page_size is not a valid integer"');
    req.throwOn(401, GlobalErrorResponseSchema1Error, '');
    req.throwOn(404, ApiError, '"segment_id" : "Returned if segment_id is not valid"\n"segment_id" : "Returned if segment_id does not exist"');
    return req.callAsJson(
      listRecipientsOnaSegmentresponseSchema,
      requestOptions
    );
  }
}
