/**
 * Twilio SendGrid v3 APILib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

import { ApiError } from '@apimatic/core';
import { ApiResponse, RequestOptions } from '../core';
import {
  GlobalErrorResponseSchema1Error,
} from '../errors/globalErrorResponseSchema1Error';
import {
  ContactDBRecipient,
  contactDBRecipientSchema,
} from '../models/contactDBRecipient';
import {
  ContactDBRecipientCount,
  contactDBRecipientCountSchema,
} from '../models/contactDBRecipientCount';
import {
  ContactDBRecipientresponse,
  contactDBRecipientresponseSchema,
} from '../models/contactDBRecipientresponse';
import {
  ContentTypeEnum,
  contentTypeEnumSchema,
} from '../models/contentTypeEnum';
import {
  ListRecipientsresponse,
  listRecipientsresponseSchema,
} from '../models/listRecipientsresponse';
import {
  V3ContactdbListsRecipientsResponse,
  v3ContactdbListsRecipientsResponseSchema,
} from '../models/v3ContactdbListsRecipientsResponse';
import {
  V3ContactdbRecipientsListsResponse,
  v3ContactdbRecipientsListsResponseSchema,
} from '../models/v3ContactdbRecipientsListsResponse';
import {
  V3ContactdbRecipientsRequest,
  v3ContactdbRecipientsRequestSchema,
} from '../models/v3ContactdbRecipientsRequest';
import {
  V3ContactdbRecipientsRequest1,
  v3ContactdbRecipientsRequest1Schema,
} from '../models/v3ContactdbRecipientsRequest1';
import {
  V3ContactdbRecipientsSearchRequest,
  v3ContactdbRecipientsSearchRequestSchema,
} from '../models/v3ContactdbRecipientsSearchRequest';
import {
  V3ContactdbRecipientsSearchResponse1,
  v3ContactdbRecipientsSearchResponse1Schema,
} from '../models/v3ContactdbRecipientsSearchResponse1';
import {
  V3ContactdbStatusResponse,
  v3ContactdbStatusResponseSchema,
} from '../models/v3ContactdbStatusResponse';
import { array, number, optional, string, unknown } from '../schema';
import { BaseController } from './baseController';

export class ContactsAPIRecipientsController extends BaseController {
  /**
   * **This endpoint allows you to add a Marketing Campaigns recipient.**
   *
   * You can add custom field data as a parameter on this endpoint. We have provided an example using
   * some of the default custom fields SendGrid provides.
   *
   * The rate limit is three requests every 2 seconds. You can upload 1000  contacts per request. So the
   * maximum upload rate is 1500 recipients per second.
   *
   * @param onBehalfOf   Example: The subuser's username. This header generates the
   *                                                       API call as if the subuser account was making the call.
   * @param body
   * @return Response from the API call
   */
  async pOSTContactdbRecipients(
    onBehalfOf?: string,
    body?: V3ContactdbRecipientsRequest[],
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ContactDBRecipientresponse>> {
    const req = this.createRequest('POST', '/v3/contactdb/recipients');
    const mapped = req.prepareArgs({
      onBehalfOf: [onBehalfOf, optional(string())],
      body: [body, optional(array(v3ContactdbRecipientsRequestSchema))],
    });
    req.header('Content-Type', 'application/json');
    req.header('on-behalf-of', mapped.onBehalfOf);
    req.json(mapped.body);
    req.throwOn(400, GlobalErrorResponseSchema1Error, '"" : "Returned if request body is not valid json"');
    req.throwOn(401, GlobalErrorResponseSchema1Error, '');
    return req.callAsJson(contactDBRecipientresponseSchema, requestOptions);
  }

  /**
   * **This endpoint allows you to update one or more recipients.**
   *
   * The body of an API call to this endpoint must include an array of one or more recipient objects.
   *
   * It is of note that you can add custom field data as parameters on recipient objects. We have
   * provided an example using some of the default custom fields SendGrid provides.
   *
   * @param onBehalfOf   Example: The subuser's username. This header generates the
   *                                                        API call as if the subuser account was making the call.
   * @param body
   * @return Response from the API call
   */
  async pATCHContactdbRecipients(
    onBehalfOf?: string,
    body?: V3ContactdbRecipientsRequest1[],
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ContactDBRecipientresponse>> {
    const req = this.createRequest('PATCH', '/v3/contactdb/recipients');
    const mapped = req.prepareArgs({
      onBehalfOf: [onBehalfOf, optional(string())],
      body: [body, optional(array(v3ContactdbRecipientsRequest1Schema))],
    });
    req.header('Content-Type', 'application/json');
    req.header('on-behalf-of', mapped.onBehalfOf);
    req.json(mapped.body);
    req.throwOn(400, GlobalErrorResponseSchema1Error, '"" : "Returned if request body is not valid json"');
    req.throwOn(401, GlobalErrorResponseSchema1Error, '');
    return req.callAsJson(contactDBRecipientresponseSchema, requestOptions);
  }

  /**
   * **This endpoint allows you to deletes one or more recipients.**
   *
   * The body of an API call to this endpoint must include an array of recipient IDs of the recipients
   * you want to delete.
   *
   * @param contentType
   * @param onBehalfOf   Example: The subuser's username. This header generates the API call as if
   *                                        the subuser account was making the call.
   * @return Response from the API call
   */
  async dELETEContactdbRecipients(
    contentType: ContentTypeEnum,
    onBehalfOf?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('DELETE', '/v3/contactdb/recipients');
    const mapped = req.prepareArgs({
      contentType: [contentType, contentTypeEnumSchema],
      onBehalfOf: [onBehalfOf, optional(string())],
    });
    req.header('Content-Type', mapped.contentType);
    req.header('on-behalf-of', mapped.onBehalfOf);
    req.throwOn(400, GlobalErrorResponseSchema1Error, '"" : "Returned if no recipients are deleted"\n"" : "Returned if all of the provided recipient ids are invalid"\n"" : "Returned if request body is not valid json"');
    req.throwOn(401, GlobalErrorResponseSchema1Error, '');
    return req.callAsJson(unknown(), requestOptions);
  }

  /**
   * **This endpoint allows you to retrieve all of your Marketing Campaigns recipients.**
   *
   * Batch deletion of a page makes it possible to receive an empty page of recipients before reaching
   * the end of
   * the list of recipients. To avoid this issue; iterate over pages until a 404 is retrieved.
   *
   * @param page         Page index of first recipients to return (must be a positive integer)
   * @param pageSize     Number of recipients to return at a time (must be a positive integer between 1 and
   *                               1000)
   * @param onBehalfOf   Example: The subuser's username. This header generates the API call as if the
   *                               subuser account was making the call.
   * @return Response from the API call
   */
  async gETContactdbRecipients(
    page?: number,
    pageSize?: number,
    onBehalfOf?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ListRecipientsresponse>> {
    const req = this.createRequest('GET', '/v3/contactdb/recipients');
    const mapped = req.prepareArgs({
      page: [page, optional(number())],
      pageSize: [pageSize, optional(number())],
      onBehalfOf: [onBehalfOf, optional(string())],
    });
    req.header('on-behalf-of', mapped.onBehalfOf);
    req.query('page', mapped.page);
    req.query('page_size', mapped.pageSize);
    req.throwOn(400, ApiError, '"page" : "Returned if page is not a valid integer"\n"page" : "Returned if page is less than 1"\n"page_size" : "Returned if page_size is not a valid integer"\n"page_size" : "Returned if page_size is less than 1 or greater than 1000"');
    req.throwOn(401, GlobalErrorResponseSchema1Error, '');
    return req.callAsJson(listRecipientsresponseSchema, requestOptions);
  }

  /**
   * **This endpoint allows you to check the upload status of a Marketing Campaigns recipient.**
   *
   * @param onBehalfOf   Example: The subuser's username. This header generates the API call as if the
   *                               subuser account was making the call.
   * @return Response from the API call
   */
  async gETContactdbStatus(
    onBehalfOf?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<V3ContactdbStatusResponse>> {
    const req = this.createRequest('GET', '/v3/contactdb/status');
    const mapped = req.prepareArgs({
      onBehalfOf: [onBehalfOf, optional(string())],
    });
    req.header('on-behalf-of', mapped.onBehalfOf);
    return req.callAsJson(v3ContactdbStatusResponseSchema, requestOptions);
  }

  /**
   * **This endpoint allows you to retrieve a single recipient by ID from your contact database.**
   *
   * @param recipientId  The ID of the recipient that you want to retrieve.
   * @param onBehalfOf   Example: The subuser's username. This header generates the API call as if the
   *                               subuser account was making the call.
   * @return Response from the API call
   */
  async gETContactdbRecipientsRecipientId(
    recipientId: string,
    onBehalfOf?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ContactDBRecipient>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      recipientId: [recipientId, string()],
      onBehalfOf: [onBehalfOf, optional(string())],
    });
    req.header('on-behalf-of', mapped.onBehalfOf);
    req.appendTemplatePath`/v3/contactdb/recipients/${mapped.recipientId}`;
    req.throwOn(400, ApiError, '"recipient_id" : "Returned if recipient_id is not valid"');
    req.throwOn(401, GlobalErrorResponseSchema1Error, '');
    req.throwOn(404, ApiError, '"recipient_id" : "Returned if record for recipient id does not exist"');
    return req.callAsJson(contactDBRecipientSchema, requestOptions);
  }

  /**
   * **This endpoint allows you to delete a single recipient with the given ID from your contact database.
   * **
   *
   * > Use this to permanently delete your recipients from all of your contact lists and all segments if
   * required by applicable law.
   *
   * @param recipientId  The ID of the recipient that you want to retrieve.
   * @param onBehalfOf   Example: The subuser's username. This header generates the API call as if the
   *                               subuser account was making the call.
   * @return Response from the API call
   */
  async dELETEContactdbRecipientsRecipientId(
    recipientId: string,
    onBehalfOf?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({
      recipientId: [recipientId, string()],
      onBehalfOf: [onBehalfOf, optional(string())],
    });
    req.header('on-behalf-of', mapped.onBehalfOf);
    req.appendTemplatePath`/v3/contactdb/recipients/${mapped.recipientId}`;
    req.throwOn(400, GlobalErrorResponseSchema1Error, '"recipient_id" : "Returned if recipient_id is not valid"');
    req.throwOn(401, GlobalErrorResponseSchema1Error, '');
    req.throwOn(404, GlobalErrorResponseSchema1Error, '"recipient_id" : "Returned if record for recipient id does not exist"');
    return req.callAsJson(unknown(), requestOptions);
  }

  /**
   * **This endpoint allows you to retrieve the lists that a given recipient belongs to.**
   *
   * Each recipient can be on many lists. This endpoint gives you all of the lists that any one recipient
   * has been added to.
   *
   * @param recipientId  The ID of the recipient for whom you are retrieving lists.
   * @param onBehalfOf   Example: The subuser's username. This header generates the API call as if the
   *                               subuser account was making the call.
   * @return Response from the API call
   */
  async gETContactdbRecipientsRecipientIdLists(
    recipientId: string,
    onBehalfOf?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<V3ContactdbRecipientsListsResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      recipientId: [recipientId, string()],
      onBehalfOf: [onBehalfOf, optional(string())],
    });
    req.header('on-behalf-of', mapped.onBehalfOf);
    req.appendTemplatePath`/v3/contactdb/recipients/${mapped.recipientId}/lists`;
    req.throwOn(400, GlobalErrorResponseSchema1Error, '"recipient_id" : "Returned if recipient_id is not valid"');
    req.throwOn(401, GlobalErrorResponseSchema1Error, '');
    req.throwOn(404, GlobalErrorResponseSchema1Error, '"recipient_id" : "Returned if record for the recipient id does not exist"');
    return req.callAsJson(
      v3ContactdbRecipientsListsResponseSchema,
      requestOptions
    );
  }

  /**
   * **This endpoint allows you to retrieve the number of Marketing Campaigns recipients that you will be
   * billed for.**
   *
   * You are billed for marketing campaigns based on the highest number of recipients you have had in
   * your account at one time. This endpoint will allow you to know the current billable count value.
   *
   * @param onBehalfOf   Example: The subuser's username. This header generates the API call as if the
   *                               subuser account was making the call.
   * @return Response from the API call
   */
  async gETContactdbRecipientsBillableCount(
    onBehalfOf?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ContactDBRecipientCount>> {
    const req = this.createRequest(
      'GET',
      '/v3/contactdb/recipients/billable_count'
    );
    const mapped = req.prepareArgs({
      onBehalfOf: [onBehalfOf, optional(string())],
    });
    req.header('on-behalf-of', mapped.onBehalfOf);
    req.throwOn(401, GlobalErrorResponseSchema1Error, '');
    return req.callAsJson(contactDBRecipientCountSchema, requestOptions);
  }

  /**
   * **This endpoint allows you to retrieve the total number of Marketing Campaigns recipients.**
   *
   * @param onBehalfOf   Example: The subuser's username. This header generates the API call as if the
   *                               subuser account was making the call.
   * @return Response from the API call
   */
  async gETContactdbRecipientsCount(
    onBehalfOf?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ContactDBRecipientCount>> {
    const req = this.createRequest('GET', '/v3/contactdb/recipients/count');
    const mapped = req.prepareArgs({
      onBehalfOf: [onBehalfOf, optional(string())],
    });
    req.header('on-behalf-of', mapped.onBehalfOf);
    req.throwOn(401, GlobalErrorResponseSchema1Error, '');
    return req.callAsJson(contactDBRecipientCountSchema, requestOptions);
  }

  /**
   * **This endpoint allows you to perform a search on all of your Marketing Campaigns recipients.**
   *
   * field_name:
   *
   * * is a variable that is substituted for your actual custom field name from your recipient.
   * * Text fields must be url-encoded. Date fields are searchable only by unix timestamp (e.g. 2/2/2015
   * becomes 1422835200)
   * * If field_name is a 'reserved' date field, such as created_at or updated_at, the system will
   * internally convert
   * your epoch time to a date range encompassing the entire day. For example, an epoch time of
   * 1422835600 converts to
   * Mon, 02 Feb 2015 00:06:40 GMT, but internally the system will search from Mon, 02 Feb 2015 00:00:00
   * GMT through
   * Mon, 02 Feb 2015 23:59:59 GMT.
   *
   * @param fieldName
   * @param onBehalfOf   Example: The subuser's username. This header generates the API call as if the
   *                               subuser account was making the call.
   * @return Response from the API call
   */
  async gETContactdbRecipientsSearch(
    fieldName?: string,
    onBehalfOf?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<V3ContactdbListsRecipientsResponse>> {
    const req = this.createRequest('GET', '/v3/contactdb/recipients/search');
    const mapped = req.prepareArgs({
      fieldName: [fieldName, optional(string())],
      onBehalfOf: [onBehalfOf, optional(string())],
    });
    req.header('on-behalf-of', mapped.onBehalfOf);
    req.query('{field_name}', mapped.fieldName);
    req.throwOn(400, GlobalErrorResponseSchema1Error, '"" : "Returned if no search params are specified"\n"field" : "Returned if the provided field is invalid or does not exist"');
    req.throwOn(401, GlobalErrorResponseSchema1Error, '');
    return req.callAsJson(
      v3ContactdbListsRecipientsResponseSchema,
      requestOptions
    );
  }

  /**
   * <p>
   * Search using segment conditions without actually creating a segment.
   * Body contains a JSON object with <code>conditions</code>, a list of conditions as described below,
   * and an optional <code>list_id</code>, which is a valid list ID for a list to limit the search on.
   * </p>
   *
   * <p>
   * Valid operators for create and update depend on the type of the field for which you are searching.
   * </p>
   *
   * <ul>
   * <li>Dates:
   * <ul>
   * <li>"eq", "ne", "lt" (before), "gt" (after)
   * <ul>
   * <li>You may use MM/DD/YYYY for day granularity or an epoch for second granularity.</li>
   * </ul>
   * </li>
   * <li>"empty", "not_empty"</li>
   * <li>"is within"
   * <ul>
   * <li>You may use an <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601 date
   * format</a> or the # of days.</li>
   * </ul>
   * </li>
   * </ul>
   * </li>
   * <li>Text: "contains", "eq" (is - matches the full field), "ne" (is not - matches any field where
   * the entire field is not the condition value), "empty", "not_empty"</li>
   * <li>Numbers: "eq", "lt", "gt", "empty", "not_empty"</li>
   * <li>Email Clicks and Opens: "eq" (opened), "ne" (not opened)</li>
   * </ul>
   *
   * <p>
   * Field values must all be a string.
   * </p>
   *
   * <p>
   * Search conditions using "eq" or "ne" for email clicks and opens should provide a "field" of either
   * <code>clicks.campaign_identifier</code> or <code>opens.campaign_identifier</code>.
   * The condition value should be a string containing the id of a completed campaign.
   * </p>
   *
   * <p>
   * Search conditions list may contain multiple conditions, joined by an "and" or "or" in the "and_or"
   * field.
   * The first condition in the conditions list must have an empty "and_or", and subsequent conditions
   * must all specify an "and_or".
   * </p>
   *
   * @param body
   * @return Response from the API call
   */
  async pOSTContactdbRecipientsSearch(
    body?: V3ContactdbRecipientsSearchRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<V3ContactdbRecipientsSearchResponse1>> {
    const req = this.createRequest('POST', '/v3/contactdb/recipients/search');
    const mapped = req.prepareArgs({
      body: [body, optional(v3ContactdbRecipientsSearchRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    req.throwOn(400, ApiError, '');
    return req.callAsJson(
      v3ContactdbRecipientsSearchResponse1Schema,
      requestOptions
    );
  }
}
