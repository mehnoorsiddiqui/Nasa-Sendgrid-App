/**
 * Twilio SendGrid v3 APILib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

import { ApiError } from '@apimatic/core';
import { ApiResponse, RequestOptions } from '../core';
import {
  GlobalErrorResponseSchema1Error,
} from '../errors/globalErrorResponseSchema1Error';
import {
  CampaignsRequest,
  campaignsRequestSchema,
} from '../models/campaignsRequest';
import {
  CampaignsResponse,
  campaignsResponseSchema,
} from '../models/campaignsResponse';
import {
  ScheduleaCampaignrequest,
  scheduleaCampaignrequestSchema,
} from '../models/scheduleaCampaignrequest';
import {
  ScheduleaCampaignresponse,
  scheduleaCampaignresponseSchema,
} from '../models/scheduleaCampaignresponse';
import {
  SendaCampaignresponse,
  sendaCampaignresponseSchema,
} from '../models/sendaCampaignresponse';
import {
  SendaTestCampaignrequest,
  sendaTestCampaignrequestSchema,
} from '../models/sendaTestCampaignrequest';
import {
  UpdateaCampaignrequest,
  updateaCampaignrequestSchema,
} from '../models/updateaCampaignrequest';
import {
  UpdateaScheduledCampaignrequest,
  updateaScheduledCampaignrequestSchema,
} from '../models/updateaScheduledCampaignrequest';
import {
  UpdateaScheduledCampaignresponse,
  updateaScheduledCampaignresponseSchema,
} from '../models/updateaScheduledCampaignresponse';
import {
  V3CampaignsResponse,
  v3CampaignsResponseSchema,
} from '../models/v3CampaignsResponse';
import {
  V3CampaignsResponse1,
  v3CampaignsResponse1Schema,
} from '../models/v3CampaignsResponse1';
import {
  V3CampaignsSchedulesTestRequest,
  v3CampaignsSchedulesTestRequestSchema,
} from '../models/v3CampaignsSchedulesTestRequest';
import { nullable, number, optional, string, unknown } from '../schema';
import { BaseController } from './baseController';

export class CampaignsAPIController extends BaseController {
  /**
   * **This endpoint allows you to create a campaign.**
   *
   * In order to send or schedule the campaign, you will be required to provide a subject, sender ID,
   * content (we suggest both html and plain text), and at least one list or segment ID. This information
   * is not required when you create a campaign.
   *
   * @param onBehalfOf   Example: The subuser's username. This header generates the API
   *                                                call as if the subuser account was making the call.
   * @param body
   * @return Response from the API call
   */
  async pOSTCampaigns(
    onBehalfOf?: string,
    body?: CampaignsRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<CampaignsResponse>> {
    const req = this.createRequest('POST', '/v3/campaigns');
    const mapped = req.prepareArgs({
      onBehalfOf: [onBehalfOf, optional(string())],
      body: [body, optional(campaignsRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.header('on-behalf-of', mapped.onBehalfOf);
    req.json(mapped.body);
    req.throwOn(400, GlobalErrorResponseSchema1Error, '"title": "title can\'t be blank"\n"title": "title is too long (maximum is 100 characters)"\n"categories": "categories exceeds 10 category limit"\n"html_content": "html_content exceeds the 1MB limit"\n"plain_content": "plain_content exceeds the 1MB limit"\n"sender_id": "sender_id does not exist"\n"sender_id": "sender_id is not a verified sender identity"\n"list_ids": "list_ids do not all exist"\n"segment_ids": "segment_ids do not all exist"\n"ip_pool": "The ip pool you provided is invalid"\n"suppression_group_id": "suppression_group_id does not exist"\n"unsubscribes": "Either suppression_group_id or custom_unsubscribe_url may be set/used, but not both. Please remove one before setting the other."\n"": "The JSON you have submitted cannot be parsed."\n"": "You\'ve reached your limit of 250 campaigns. Please delete one or more and try again."');
    req.throwOn(401, ApiError, '');
    return req.callAsJson(campaignsResponseSchema, requestOptions);
  }

  /**
   * **This endpoint allows you to retrieve a list of all of your campaigns.**
   *
   * Returns campaigns in reverse order they were created (newest first).
   *
   * Returns an empty array if no campaigns exist.
   *
   * @param limit        The number of results you would like to receive at a time.
   * @param offset       The index of the first campaign to return, where 0 is the first campaign.
   * @param onBehalfOf   Example: The subuser's username. This header generates the API call as if the
   *                               subuser account was making the call.
   * @return Response from the API call
   */
  async gETCampaigns(
    limit?: number,
    offset?: number,
    onBehalfOf?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<V3CampaignsResponse>> {
    const req = this.createRequest('GET', '/v3/campaigns');
    const mapped = req.prepareArgs({
      limit: [limit, optional(number())],
      offset: [offset, optional(number())],
      onBehalfOf: [onBehalfOf, optional(string())],
    });
    req.header('on-behalf-of', mapped.onBehalfOf);
    req.query('limit', mapped.limit);
    req.query('offset', mapped.offset);
    return req.callAsJson(v3CampaignsResponseSchema, requestOptions);
  }

  /**
   * **This endpoint allows you to retrieve a specific campaign.**
   *
   * @param campaignId   The id of the campaign you would like to retrieve.
   * @param onBehalfOf   Example: The subuser's username. This header generates the API call as if the
   *                               subuser account was making the call.
   * @return Response from the API call
   */
  async gETCampaignsCampaignId(
    campaignId: number,
    onBehalfOf?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<V3CampaignsResponse1>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      campaignId: [campaignId, number()],
      onBehalfOf: [onBehalfOf, optional(string())],
    });
    req.header('on-behalf-of', mapped.onBehalfOf);
    req.appendTemplatePath`/v3/campaigns/${mapped.campaignId}`;
    req.throwOn(401, ApiError, '');
    req.throwOn(404, ApiError, '"": "not found"');
    return req.callAsJson(v3CampaignsResponse1Schema, requestOptions);
  }

  /**
   * **This endpoint allows you to delete a specific campaign.**
   *
   * @param campaignId   The id of the campaign you would like to retrieve.
   * @param onBehalfOf   Example: The subuser's username. This header generates the API call as if the
   *                               subuser account was making the call.
   * @return Response from the API call
   */
  async dELETECampaignsCampaignId(
    campaignId: number,
    onBehalfOf?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({
      campaignId: [campaignId, number()],
      onBehalfOf: [onBehalfOf, optional(string())],
    });
    req.header('on-behalf-of', mapped.onBehalfOf);
    req.appendTemplatePath`/v3/campaigns/${mapped.campaignId}`;
    req.throwOn(401, ApiError, '');
    req.throwOn(404, ApiError, '"": "not found"');
    return req.callAsJson(nullable(unknown()), requestOptions);
  }

  /**
   * **This endpoint allows you to update a specific campaign.**
   *
   * This is especially useful if you only set up the campaign using POST /campaigns, but didn't set many
   * of the parameters.
   *
   * @param campaignId   The id of the campaign you would like to retrieve.
   * @param onBehalfOf   Example: The subuser's username. This header generates the
   *                                                      API call as if the subuser account was making the call.
   * @param body
   * @return Response from the API call
   */
  async pATCHCampaignsCampaignId(
    campaignId: number,
    onBehalfOf?: string,
    body?: UpdateaCampaignrequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<CampaignsResponse>> {
    const req = this.createRequest('PATCH');
    const mapped = req.prepareArgs({
      campaignId: [campaignId, number()],
      onBehalfOf: [onBehalfOf, optional(string())],
      body: [body, optional(updateaCampaignrequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.header('on-behalf-of', mapped.onBehalfOf);
    req.json(mapped.body);
    req.appendTemplatePath`/v3/campaigns/${mapped.campaignId}`;
    req.throwOn(400, ApiError, '"title": "title can\'t be blank"\n"title": "title is too long (maximum is 100 characters)"\n"categories": "categories exceeds 10 category limit"\n"html_content": "html_content exceeds the 1MB limit"\n"plain_content": "plain_content exceeds the 1MB limit"\n"sender_id": "sender_id does not exist"\n"sender_id": "sender_id is not a verified sender identity"\n"list_ids": "list_ids do not all exist"\n"segment_ids": "segment_ids do not all exist"\n"ip_pool": "The ip pool you provided is invalid"\n"suppression_group_id": "suppression_group_id does not exist"\n"unsubscribes": "Either suppression_group_id or custom_unsubscribe_url may be set/used, but not both. Please remove one before setting the other."\n"": "The JSON you have submitted cannot be parsed."');
    req.throwOn(401, GlobalErrorResponseSchema1Error, '');
    req.throwOn(403, ApiError, '"": "You may only update a campaign when it is in draft mode."');
    req.throwOn(404, GlobalErrorResponseSchema1Error, '"": "not found"');
    return req.callAsJson(campaignsResponseSchema, requestOptions);
  }

  /**
   * **This endpoint allows you to immediately send an existing campaign.**
   *
   * Normally a POST request would have a body, but since this endpoint is telling us to send a resource
   * that is already created, a request body is not needed.
   *
   * @param campaignId
   * @param onBehalfOf   Example: The subuser's username. This header generates the API call as if the
   *                               subuser account was making the call.
   * @return Response from the API call
   */
  async pOSTCampaignsCampaignIdSchedulesNow(
    campaignId: number,
    onBehalfOf?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SendaCampaignresponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({
      campaignId: [campaignId, number()],
      onBehalfOf: [onBehalfOf, optional(string())],
    });
    req.header('on-behalf-of', mapped.onBehalfOf);
    req.appendTemplatePath`/v3/campaigns/${mapped.campaignId}/schedules/now`;
    req.throwOn(400, GlobalErrorResponseSchema1Error, '"subject": "subject can\'t be blank"\n"sender_id": "sender_id can\'t be blank"\n"plain_content": "plain_content can\'t be blank, please provide plain text or html content"\n"list_ids": "You must select at least 1 segment or 1 list to send to."\n"unsubscribe_tag": "An [unsubscribe] tag in both your html and plain content is required to send a campaign."\n"suppression_group_id": "Either a suppression_group_id or custom_unsubscribe_url is required to send a campaign."\n"": "You do not have enough credits to send this campaign. Upgrade your plan to send more: https://app.sendgrid.com/settings/billing"');
    req.throwOn(401, GlobalErrorResponseSchema1Error, '');
    req.throwOn(403, GlobalErrorResponseSchema1Error, '"": "You may only send a campaign when it is in draft mode."');
    req.throwOn(404, GlobalErrorResponseSchema1Error, '"": "not found"');
    return req.callAsJson(sendaCampaignresponseSchema, requestOptions);
  }

  /**
   * **This endpoint allows you to schedule a specific date and time for your campaign to be sent.**
   *
   * If you have the flexibility, it's better to schedule mail for off-peak times. Most emails are
   * scheduled and sent at the top of the hour or half hour. Scheduling email to avoid those times (for
   * example, scheduling at 10:53) can result in lower deferral rates because it won't be going through
   * our servers at the same times as everyone else's mail.
   *
   * @param campaignId
   * @param onBehalfOf   Example: The subuser's username. This header generates the
   *                                                        API call as if the subuser account was making the call.
   * @param body
   * @return Response from the API call
   */
  async pOSTCampaignsCampaignIdSchedules(
    campaignId: number,
    onBehalfOf?: string,
    body?: ScheduleaCampaignrequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ScheduleaCampaignresponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({
      campaignId: [campaignId, number()],
      onBehalfOf: [onBehalfOf, optional(string())],
      body: [body, optional(scheduleaCampaignrequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.header('on-behalf-of', mapped.onBehalfOf);
    req.json(mapped.body);
    req.appendTemplatePath`/v3/campaigns/${mapped.campaignId}/schedules`;
    req.throwOn(400, GlobalErrorResponseSchema1Error, '"subject": "subject can\'t be blank"\n"sender_id": "sender_id can\'t be blank"\n"plain_content": "plain_content can\'t be blank, please provide plain text or html content"\n"list_ids": "You must select at least 1 segment or 1 list to send to."\n"send_at": "Please choose a future time for sending your campaign."\n"unsubscribe_tag": "An [unsubscribe] tag in both your html and plain content is required to send a campaign."\n"suppression_group_id": "Either a suppression_group_id or custom_unsubscribe_url is required to send a campaign."\n"": "The JSON you have submitted cannot be parsed."\n"":"You do not have enough credits to send this campaign. Upgrade your plan to send more: https://app.sendgrid.com/settings/billing"');
    req.throwOn(401, GlobalErrorResponseSchema1Error, '');
    req.throwOn(403, GlobalErrorResponseSchema1Error, '"": "You cannot POST to a campaign that has already sent or scheduled. However you can update a scheduled campaign with a PATCH."');
    req.throwOn(404, GlobalErrorResponseSchema1Error, '"": "not found"');
    return req.callAsJson(scheduleaCampaignresponseSchema, requestOptions);
  }

  /**
   * **This endpoint allows to you change the scheduled time and date for a campaign to be sent.**
   *
   * @param campaignId
   * @param onBehalfOf   Example: The subuser's username. This header
   *                                                               generates the API call as if the subuser account was
   *                                                               making the call.
   * @param body
   * @return Response from the API call
   */
  async pATCHCampaignsCampaignIdSchedules(
    campaignId: number,
    onBehalfOf?: string,
    body?: UpdateaScheduledCampaignrequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<UpdateaScheduledCampaignresponse>> {
    const req = this.createRequest('PATCH');
    const mapped = req.prepareArgs({
      campaignId: [campaignId, number()],
      onBehalfOf: [onBehalfOf, optional(string())],
      body: [body, optional(updateaScheduledCampaignrequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.header('on-behalf-of', mapped.onBehalfOf);
    req.json(mapped.body);
    req.appendTemplatePath`/v3/campaigns/${mapped.campaignId}/schedules`;
    req.throwOn(400, GlobalErrorResponseSchema1Error, '"": "The JSON you have submitted cannot be parsed."\n"send_at": "Please choose a future time for sending your campaign."\n"":"You do not have enough credits to send this campaign. Upgrade your plan to send more: https://app.sendgrid.com/settings/billing"');
    req.throwOn(403, GlobalErrorResponseSchema1Error, '"send_at": "You cannot update the send_at value of non-scheduled campaign."');
    req.throwOn(404, GlobalErrorResponseSchema1Error, '"": "not found"');
    return req.callAsJson(
      updateaScheduledCampaignresponseSchema,
      requestOptions
    );
  }

  /**
   * **This endpoint allows you to retrieve the date and time that a campaign has been scheduled to be
   * sent.**
   *
   * @param campaignId
   * @param onBehalfOf   Example: The subuser's username. This header generates the API call as if the
   *                               subuser account was making the call.
   * @return Response from the API call
   */
  async gETCampaignsCampaignIdSchedules(
    campaignId: number,
    onBehalfOf?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<UpdateaScheduledCampaignrequest>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      campaignId: [campaignId, number()],
      onBehalfOf: [onBehalfOf, optional(string())],
    });
    req.header('on-behalf-of', mapped.onBehalfOf);
    req.appendTemplatePath`/v3/campaigns/${mapped.campaignId}/schedules`;
    req.throwOn(404, GlobalErrorResponseSchema1Error, '"": "not found"');
    return req.callAsJson(
      updateaScheduledCampaignrequestSchema,
      requestOptions
    );
  }

  /**
   * **This endpoint allows you to unschedule a campaign that has already been scheduled to be sent.**
   *
   * A successful unschedule will return a 204.
   * If the specified campaign is in the process of being sent, the only option is to cancel (a different
   * method).
   *
   * @param campaignId
   * @param onBehalfOf   Example: The subuser's username. This header generates the API call as if the
   *                               subuser account was making the call.
   * @return Response from the API call
   */
  async dELETECampaignsCampaignIdSchedules(
    campaignId: number,
    onBehalfOf?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({
      campaignId: [campaignId, number()],
      onBehalfOf: [onBehalfOf, optional(string())],
    });
    req.header('on-behalf-of', mapped.onBehalfOf);
    req.appendTemplatePath`/v3/campaigns/${mapped.campaignId}/schedules`;
    req.throwOn(403, GlobalErrorResponseSchema1Error, '"": "This campaign is already In Progress."\n"": "This campaign is already Sent."\n"": "This campaign is already Paused."\n"": "This campaign is already Canceled."');
    req.throwOn(404, GlobalErrorResponseSchema1Error, '"": "not found"');
    return req.callAsJson(nullable(unknown()), requestOptions);
  }

  /**
   * **This endpoint allows you to send a test campaign.**
   *
   * To send to multiple addresses, use an array for the JSON "to" value ["one@address","two@address"]
   *
   * @param campaignId
   * @param onBehalfOf   Example: The subuser's username. This header
   *                                                               generates the API call as if the subuser account was
   *                                                               making the call.
   * @param body
   * @return Response from the API call
   */
  async pOSTCampaignsCampaignIdSchedulesTest(
    campaignId: number,
    onBehalfOf?: string,
    body?: V3CampaignsSchedulesTestRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SendaTestCampaignrequest>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({
      campaignId: [campaignId, number()],
      onBehalfOf: [onBehalfOf, optional(string())],
      body: [body, optional(v3CampaignsSchedulesTestRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.header('on-behalf-of', mapped.onBehalfOf);
    req.json(mapped.body);
    req.appendTemplatePath`/v3/campaigns/${mapped.campaignId}/schedules/test`;
    req.throwOn(400, GlobalErrorResponseSchema1Error, '"": "The JSON you have submitted cannot be parsed."\n"to": "Please provide an email address to which the test should be sent."\n"to": "You can only send tests to 10 addresses at a time."\n"subject": "Please add a subject to your campaign before sending a test."\n"plain_content": "Plain content and html content can\'t both be blank. Please set one of these values before sending a test."\n"sender_id": "Please assign a sender identity to your campaign before sending a test."');
    req.throwOn(404, GlobalErrorResponseSchema1Error, '"": "not found"');
    return req.callAsJson(sendaTestCampaignrequestSchema, requestOptions);
  }
}
