/**
 * Twilio SendGrid v3 APILib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

import { ApiResponse, RequestOptions } from '../core';
import {
  GlobalErrorResponseSchema1Error,
} from '../errors/globalErrorResponseSchema1Error';
import {
  ListallassignedIPsresponse,
  listallassignedIPsresponseSchema,
} from '../models/listallassignedIPsresponse';
import {
  SortByDirection4Enum,
  sortByDirection4EnumSchema,
} from '../models/sortByDirection4Enum';
import {
  V3IpsRemainingResponse,
  v3IpsRemainingResponseSchema,
} from '../models/v3IpsRemainingResponse';
import { V3IpsRequest, v3IpsRequestSchema } from '../models/v3IpsRequest';
import { V3IpsResponse, v3IpsResponseSchema } from '../models/v3IpsResponse';
import { V3IpsResponse1, v3IpsResponse1Schema } from '../models/v3IpsResponse1';
import { V3IpsResponse2, v3IpsResponse2Schema } from '../models/v3IpsResponse2';
import { array, boolean, number, optional, string } from '../schema';
import { BaseController } from './baseController';

export class IPAddressesController extends BaseController {
  /**
   * **This endpoint is for adding a(n) IP Address(es) to your account.**
   *
   * @param body
   * @return Response from the API call
   */
  async pOSTIps(
    body?: V3IpsRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<V3IpsResponse>> {
    const req = this.createRequest('POST', '/v3/ips');
    const mapped = req.prepareArgs({
      body: [body, optional(v3IpsRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    req.throwOn(400, GlobalErrorResponseSchema1Error, '');
    return req.callAsJson(v3IpsResponseSchema, requestOptions);
  }

  /**
   * **This endpoint allows you to retrieve a list of all assigned and unassigned IPs.**
   *
   * Response includes warm up status, pools, assigned subusers, and reverse DNS info. The start_date
   * field corresponds to when warmup started for that IP.
   *
   * A single IP address or a range of IP addresses may be dedicated to an account in order to send email
   * for multiple domains. The reputation of this IP is based on the aggregate performance of all the
   * senders who use it.
   *
   * @param ip                  The IP address to get
   * @param excludeWhitelabels  Should we exclude reverse DNS records (whitelabels)?
   * @param limit               The number of IPs you want returned at the same time.
   * @param offset              The offset for the number of IPs that you are requesting.
   * @param subuser             The subuser you are requesting for.
   * @param sortByDirection     The direction to sort the results.
   * @return Response from the API call
   */
  async gETIps(
    ip?: string,
    excludeWhitelabels?: boolean,
    limit?: number,
    offset?: number,
    subuser?: string,
    sortByDirection?: SortByDirection4Enum,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<V3IpsResponse1[]>> {
    const req = this.createRequest('GET', '/v3/ips');
    const mapped = req.prepareArgs({
      ip: [ip, optional(string())],
      excludeWhitelabels: [excludeWhitelabels, optional(boolean())],
      limit: [limit, optional(number())],
      offset: [offset, optional(number())],
      subuser: [subuser, optional(string())],
      sortByDirection: [sortByDirection, optional(sortByDirection4EnumSchema)],
    });
    req.query('ip', mapped.ip);
    req.query('exclude_whitelabels', mapped.excludeWhitelabels);
    req.query('limit', mapped.limit);
    req.query('offset', mapped.offset);
    req.query('subuser', mapped.subuser);
    req.query('sort_by_direction', mapped.sortByDirection);
    return req.callAsJson(array(v3IpsResponse1Schema), requestOptions);
  }

  /**
   * **This endpoint gets amount of IP Addresses that can still be created during a given period and the
   * price of those IPs.**
   *
   * @return Response from the API call
   */
  async gETIpsRemaining(
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<V3IpsRemainingResponse>> {
    const req = this.createRequest('GET', '/v3/ips/remaining');
    return req.callAsJson(v3IpsRemainingResponseSchema, requestOptions);
  }

  /**
   * **This endpoint allows you to retrieve only assigned IP addresses.**
   *
   * A single IP address or a range of IP addresses may be dedicated to an account in order to send email
   * for multiple domains. The reputation of this IP is based on the aggregate performance of all the
   * senders who use it.
   *
   * @return Response from the API call
   */
  async gETIpsAssigned(
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ListallassignedIPsresponse[]>> {
    const req = this.createRequest('GET', '/v3/ips/assigned');
    return req.callAsJson(
      array(listallassignedIPsresponseSchema),
      requestOptions
    );
  }

  /**
   * **This endpoint allows you to see which IP pools a particular IP address has been added to.**
   *
   * The same IP address can be added to multiple IP pools.
   *
   * A single IP address or a range of IP addresses may be dedicated to an account in order to send email
   * for multiple domains. The reputation of this IP is based on the aggregate performance of all the
   * senders who use it.
   *
   * @param ipAddress  The IP address you are retrieving the IP pools for.
   * @return Response from the API call
   */
  async gETIpsIpAddress(
    ipAddress: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<V3IpsResponse2>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ ipAddress: [ipAddress, string()] });
    req.appendTemplatePath`/v3/ips/${mapped.ipAddress}`;
    return req.callAsJson(v3IpsResponse2Schema, requestOptions);
  }
}
