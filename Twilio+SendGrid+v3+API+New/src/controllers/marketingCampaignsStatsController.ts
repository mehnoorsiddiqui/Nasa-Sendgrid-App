/**
 * Twilio SendGrid v3 APILib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

import { ApiError } from '@apimatic/core';
import { ApiResponse, RequestOptions } from '../core';
import {
  GlobalErrorResponseSchema1Error,
} from '../errors/globalErrorResponseSchema1Error';
import { AbPhaseIdEnum, abPhaseIdEnumSchema } from '../models/abPhaseIdEnum';
import {
  AggregatedBy11Enum,
  aggregatedBy11EnumSchema,
} from '../models/aggregatedBy11Enum';
import {
  AutomationsLinkStatsResponse,
  automationsLinkStatsResponseSchema,
} from '../models/automationsLinkStatsResponse';
import {
  AutomationsResponse,
  automationsResponseSchema,
} from '../models/automationsResponse';
import { GroupBy1Enum, groupBy1EnumSchema } from '../models/groupBy1Enum';
import { GroupByEnum, groupByEnumSchema } from '../models/groupByEnum';
import {
  SinglesendsLinkStatsResponse,
  singlesendsLinkStatsResponseSchema,
} from '../models/singlesendsLinkStatsResponse';
import {
  SinglesendsResponse,
  singlesendsResponseSchema,
} from '../models/singlesendsResponse';
import { array, number, optional, string } from '../schema';
import { BaseController } from './baseController';

export class MarketingCampaignsStatsController extends BaseController {
  /**
   * **This endpoint allows you to retrieve stats for all your Automations.**
   *
   * By default, all of your Automations will be returned, but you can specify a selection by passing in
   * a comma-separated list of Automation IDs as the value of the query string parameter `automation_ids`.
   *
   * Responses are paginated. You can limit the number of responses returned per batch using the
   * `page_size` query string parameter. The default is 50, but you specify a value between 1 and 100.
   *
   * You can retrieve a specific page of responses with the `page_token` query string parameter.
   *
   * @param automationIds  This endpoint returns all automation IDs if no `automation_ids` are specified.
   * @param pageSize       The number of elements you want returned on each page.
   * @param pageToken      The stats endpoints are paginated. To get the next page, call the passed
   *                                   `_metadata.next` URL. If `_metadata.prev` doesn't exist, you're at the first
   *                                   page. Similarly, if `_metadata.next` is not present, you're at the last page.
   * @return Response from the API call
   */
  async getallAutomationStats(
    automationIds?: string[],
    pageSize?: number,
    pageToken?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AutomationsResponse>> {
    const req = this.createRequest('GET', '/v3/marketing/stats/automations');
    const mapped = req.prepareArgs({
      automationIds: [automationIds, optional(array(string()))],
      pageSize: [pageSize, optional(number())],
      pageToken: [pageToken, optional(string())],
    });
    req.query('automation_ids', mapped.automationIds);
    req.query('page_size', mapped.pageSize);
    req.query('page_token', mapped.pageToken);
    req.throwOn(400, GlobalErrorResponseSchema1Error, '');
    return req.callAsJson(automationsResponseSchema, requestOptions);
  }

  /**
   * **This endpoint allows you to retrieve stats for a single Automation using its ID.**
   *
   * Multiple Automation IDs can be retrieved using the "Get All Automation Stats" endpoint. Once you
   * have an ID, this endpoint will return detailed stats for the single automation specified.
   *
   * You may constrain the stats returned using the `start_date` and `end_date` query string parameters.
   * You can also use the `group_by` and `aggregated_by` query string parameters to further refine the
   * stats returned.
   *
   * @param id
   * @param groupBy       Automations can have multiple steps. Including `step_id` as a
   *                                            `group_by` metric allows further granularity of stats.
   * @param stepIds       Comma-separated list of `step_ids` that you want the link stats for.
   * @param aggregatedBy  Dictates how the stats are time-sliced. Currently, `"total"` and
   *                                            `"day"` are supported.
   * @param startDate     Format: `YYYY-MM-DD`. If this parameter is included, the stats' start
   *                                            date is included in the search.
   * @param endDate       Format: `YYYY-MM-DD`.If this parameter is included, the stats' end
   *                                            date is included in the search.
   * @param timezone      [IANA Area/Region](https://en.wikipedia.
   *                                            org/wiki/Tz_database#Names_of_time_zones) string representing the
   *                                            timezone in which the stats are to be presented, e.g.,
   *                                            "America/Chicago".
   * @param pageSize      The number of elements you want returned on each page.
   * @param pageToken     The stats endpoints are paginated. To get the next page, call the
   *                                            passed `_metadata.next` URL. If `_metadata.prev` doesn't exist, you're
   *                                            at the first page. Similarly, if `_metadata.next` is not present,
   *                                            you're at the last page.
   * @return Response from the API call
   */
  async getAutomationStat(
    id: string,
    groupBy?: GroupByEnum[],
    stepIds?: string[],
    aggregatedBy?: AggregatedBy11Enum,
    startDate?: string,
    endDate?: string,
    timezone?: string,
    pageSize?: number,
    pageToken?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AutomationsResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      id: [id, string()],
      groupBy: [groupBy, optional(array(groupByEnumSchema))],
      stepIds: [stepIds, optional(array(string()))],
      aggregatedBy: [aggregatedBy, optional(aggregatedBy11EnumSchema)],
      startDate: [startDate, optional(string())],
      endDate: [endDate, optional(string())],
      timezone: [timezone, optional(string())],
      pageSize: [pageSize, optional(number())],
      pageToken: [pageToken, optional(string())],
    });
    req.query('group_by', mapped.groupBy);
    req.query('step_ids', mapped.stepIds);
    req.query('aggregated_by', mapped.aggregatedBy);
    req.query('start_date', mapped.startDate);
    req.query('end_date', mapped.endDate);
    req.query('timezone', mapped.timezone);
    req.query('page_size', mapped.pageSize);
    req.query('page_token', mapped.pageToken);
    req.appendTemplatePath`/v3/marketing/stats/automations/${mapped.id}`;
    req.throwOn(400, GlobalErrorResponseSchema1Error, '');
    req.throwOn(404, ApiError, '');
    return req.callAsJson(automationsResponseSchema, requestOptions);
  }

  /**
   * **This endpoint allows you to retrieve stats for all your Single Sends.**
   *
   * By default, all of your Single Sends will be returned, but you can specify a selection by passing in
   * a comma-separated list of Single Send IDs as the value of the query string parameter
   * `singlesend_ids`.
   *
   * Responses are paginated. You can limit the number of responses returned per batch using the
   * `page_size` query string parameter. The default is 50, but you specify a value between 1 and 100.
   *
   * You can retrieve a specific page of responses with the `page_token` query string parameter.
   *
   * @param singlesendIds  This endpoint returns all Single Send IDs if no IDs are included in
   *                                   `singlesend_ids`.
   * @param pageSize       The number of elements you want returned on each page.
   * @param pageToken      The stats endpoints are paginated. To get the next page, call the passed
   *                                   `_metadata.next` URL. If `_metadata.prev` doesn't exist, you're at the first
   *                                   page. Similarly, if `_metadata.next` is not present, you're at the last page.
   * @return Response from the API call
   */
  async getallSinglesendStats(
    singlesendIds?: string[],
    pageSize?: number,
    pageToken?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SinglesendsResponse>> {
    const req = this.createRequest('GET', '/v3/marketing/stats/singlesends');
    const mapped = req.prepareArgs({
      singlesendIds: [singlesendIds, optional(array(string()))],
      pageSize: [pageSize, optional(number())],
      pageToken: [pageToken, optional(string())],
    });
    req.query('singlesend_ids', mapped.singlesendIds);
    req.query('page_size', mapped.pageSize);
    req.query('page_token', mapped.pageToken);
    req.throwOn(400, GlobalErrorResponseSchema1Error, '');
    return req.callAsJson(singlesendsResponseSchema, requestOptions);
  }

  /**
   * **This endpoint allows you to retrieve stats for an individual Single Send using a Single Send ID.
   * **
   *
   * Multiple Single Send IDs can be retrieved using the "Get All Single Sends Stats" endpoint. Once you
   * have an ID, this endpoint will return detailed stats for the Single Send specified.
   *
   * You may constrain the stats returned using the `start_date` and `end_date` query string parameters.
   * You can also use the `group_by` and `aggregated_by` query string parameters to further refine the
   * stats returned.
   *
   * @param id
   * @param aggregatedBy  Dictates how the stats are time-sliced. Currently, `"total"` and
   *                                            `"day"` are supported.
   * @param startDate     Format: `YYYY-MM-DD`. If this parameter is included, the stats' start
   *                                            date is included in the search.
   * @param endDate       Format: `YYYY-MM-DD`.If this parameter is included, the stats' end
   *                                            date is included in the search.
   * @param timezone      [IANA Area/Region](https://en.wikipedia.
   *                                            org/wiki/Tz_database#Names_of_time_zones) string representing the
   *                                            timezone in which the stats are to be presented, e.g.,
   *                                            "America/Chicago".
   * @param pageSize      The number of elements you want returned on each page.
   * @param pageToken     The stats endpoints are paginated. To get the next page, call the
   *                                            passed `_metadata.next` URL. If `_metadata.prev` doesn't exist, you're
   *                                            at the first page. Similarly, if `_metadata.next` is not present,
   *                                            you're at the last page.
   * @param groupBy       A/B Single Sends have multiple variation IDs and phase IDs. Including
   *                                            these additional fields allows further granularity of stats by these
   *                                            fields.
   * @return Response from the API call
   */
  async getSinglesendStat(
    id: string,
    aggregatedBy?: AggregatedBy11Enum,
    startDate?: string,
    endDate?: string,
    timezone?: string,
    pageSize?: number,
    pageToken?: string,
    groupBy?: GroupBy1Enum[],
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SinglesendsResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      id: [id, string()],
      aggregatedBy: [aggregatedBy, optional(aggregatedBy11EnumSchema)],
      startDate: [startDate, optional(string())],
      endDate: [endDate, optional(string())],
      timezone: [timezone, optional(string())],
      pageSize: [pageSize, optional(number())],
      pageToken: [pageToken, optional(string())],
      groupBy: [groupBy, optional(array(groupBy1EnumSchema))],
    });
    req.query('aggregated_by', mapped.aggregatedBy);
    req.query('start_date', mapped.startDate);
    req.query('end_date', mapped.endDate);
    req.query('timezone', mapped.timezone);
    req.query('page_size', mapped.pageSize);
    req.query('page_token', mapped.pageToken);
    req.query('group_by', mapped.groupBy);
    req.appendTemplatePath`/v3/marketing/stats/singlesends/${mapped.id}`;
    req.throwOn(400, GlobalErrorResponseSchema1Error, '');
    req.throwOn(404, ApiError, '');
    return req.callAsJson(singlesendsResponseSchema, requestOptions);
  }

  /**
   * **This endpoint lets you retrieve click-tracking stats for a single Automation**.
   *
   * The stats returned list the URLs embedded in your Automation and the number of clicks each one
   * received.
   *
   * Responses are paginated. You can limit the number of responses returned per batch using the
   * `page_size` query string parameter. The default is 50, but you specify a value between 1 and 100.
   *
   * You can retrieve a specific page of responses with the `page_token` query string parameter.
   *
   * @param id         The ID of the Automation you want to get click tracking stats for.
   * @param groupBy    Automations can have multiple steps. Including `step_id` as a `group_by`
   *                                    metric allows further granularity of stats.
   * @param stepIds    Comma-separated list of `step_ids` that you want the link stats for.
   * @param pageSize   The number of elements you want returned on each page.
   * @param pageToken  The stats endpoints are paginated. To get the next page, call the passed
   *                                    `_metadata.next` URL. If `_metadata.prev` doesn't exist, you're at the first
   *                                    page. Similarly, if `_metadata.next` is not present, you're at the last page.
   * @return Response from the API call
   */
  async getAutomationLinkStat(
    id: string,
    groupBy?: GroupByEnum[],
    stepIds?: string[],
    pageSize?: number,
    pageToken?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AutomationsLinkStatsResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      id: [id, string()],
      groupBy: [groupBy, optional(array(groupByEnumSchema))],
      stepIds: [stepIds, optional(array(string()))],
      pageSize: [pageSize, optional(number())],
      pageToken: [pageToken, optional(string())],
    });
    req.query('group_by', mapped.groupBy);
    req.query('step_ids', mapped.stepIds);
    req.query('page_size', mapped.pageSize);
    req.query('page_token', mapped.pageToken);
    req.appendTemplatePath`/v3/marketing/stats/automations/${mapped.id}/links`;
    req.throwOn(400, GlobalErrorResponseSchema1Error, '');
    req.throwOn(404, GlobalErrorResponseSchema1Error, '');
    return req.callAsJson(automationsLinkStatsResponseSchema, requestOptions);
  }

  /**
   * **This endpoint lets you retrieve click-tracking stats for one Single Send**.
   *
   * The stats returned list the URLs embedded in the specified Single Send and the number of clicks each
   * one received.
   *
   * Responses are paginated. You can limit the number of responses returned per batch using the
   * `page_size` query string parameter. The default is 50, but you specify a value between 1 and 100.
   *
   * You can retrieve a specific page of responses with the `page_token` query string parameter.
   *
   * @param id
   * @param pageSize        The number of elements you want returned on each page.
   * @param pageToken       The stats endpoints are paginated. To get the next page, call the passed
   *                                          `_metadata.next` URL. If `_metadata.prev` doesn't exist, you're at the
   *                                          first page. Similarly, if `_metadata.next` is not present, you're at the
   *                                          last page.
   * @param groupBy         A/B Single Sends have multiple variation IDs and phase IDs. Including
   *                                          these additional fields allows further granularity of stats by these
   *                                          fields.
   * @param abVariationId
   * @param abPhaseId
   * @return Response from the API call
   */
  async getSinglesendLinkStat(
    id: string,
    pageSize?: number,
    pageToken?: string,
    groupBy?: GroupBy1Enum[],
    abVariationId?: string,
    abPhaseId?: AbPhaseIdEnum,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SinglesendsLinkStatsResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      id: [id, string()],
      pageSize: [pageSize, optional(number())],
      pageToken: [pageToken, optional(string())],
      groupBy: [groupBy, optional(array(groupBy1EnumSchema))],
      abVariationId: [abVariationId, optional(string())],
      abPhaseId: [abPhaseId, optional(abPhaseIdEnumSchema)],
    });
    req.query('page_size', mapped.pageSize);
    req.query('page_token', mapped.pageToken);
    req.query('group_by', mapped.groupBy);
    req.query('ab_variation_id', mapped.abVariationId);
    req.query('ab_phase_id', mapped.abPhaseId);
    req.appendTemplatePath`/v3/marketing/stats/singlesends/${mapped.id}/links`;
    req.throwOn(400, GlobalErrorResponseSchema1Error, '');
    req.throwOn(404, ApiError, '');
    return req.callAsJson(singlesendsLinkStatsResponseSchema, requestOptions);
  }

  /**
   * **This endpoint allows you to export Single Send stats as .CSV data**.
   *
   * You can specify one Single Send or many: include as many Single Send IDs as you need, separating
   * them with commas, as the value of the `ids` query string paramter.
   *
   * The data is returned as plain text response but in .CSV format, so your application making the call
   * can present the information in whatever way is most appropriate, or just save the data as a .csv
   * file.
   *
   * @param ids      The IDs of Single Sends for which to export stats.
   * @param timezone The [IANA Area/Region](https://en.wikipedia.org/wiki/Tz_database#Names_of_time_zones)
   *                             string representing the timezone in which the stats are to be presented; i.e.
   *                             `"America/Chicago"`. This parameter changes the timezone format only; it does not
   *                             alter which stats are returned.
   * @return Response from the API call
   */
  async getSinglesendStatsExport(
    ids?: string[],
    timezone?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<string>> {
    const req = this.createRequest(
      'GET',
      '/v3/marketing/stats/singlesends/export'
    );
    const mapped = req.prepareArgs({
      ids: [ids, optional(array(string()))],
      timezone: [timezone, optional(string())],
    });
    req.query('ids', mapped.ids);
    req.query('timezone', mapped.timezone);
    req.throwOn(400, ApiError, '');
    return req.callAsText(requestOptions);
  }

  /**
   * **This endpoint allows you to export Automation stats as CSV data**.
   *
   * You can specify one Automation or many: include as many Automation IDs as you need, separating them
   * with commas, as the value of the `ids` query string paramter.
   *
   * The data is returned as plain text response but in CSV format, so your application making the call
   * can present the information in whatever way is most appropriate, or just save the data as a `.csv`
   * file.
   *
   * @param ids      The IDs of Automations for which to export stats.
   * @param timezone The [IANA Area/Region](https://en.wikipedia.org/wiki/Tz_database#Names_of_time_zones)
   *                             string representing the timezone in which the stats are to be presented; i.e.
   *                             `"America/Chicago"`. This parameter changes the timezone format only; it does not
   *                             alter which stats are returned.
   * @return Response from the API call
   */
  async getAutomationsStatsExport(
    ids?: string[],
    timezone?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<string>> {
    const req = this.createRequest(
      'GET',
      '/v3/marketing/stats/automations/export'
    );
    const mapped = req.prepareArgs({
      ids: [ids, optional(array(string()))],
      timezone: [timezone, optional(string())],
    });
    req.query('ids', mapped.ids);
    req.query('timezone', mapped.timezone);
    req.throwOn(400, GlobalErrorResponseSchema1Error, '');
    return req.callAsText(requestOptions);
  }
}
